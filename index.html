<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello WebXR!</title>
    <script src="https://cdn.rawgit.com/google-ar/three.ar.js/v3.0.0/build/three-ar.js"></script>
    <style>
      /* Add styles as needed */
    </style>
  </head>
  <body>
    <h1>Hello WebXR!</h1>

    <div id="info">
      <!-- Add information here -->
    </div>

    <script>
      // Use the 'webxr' namespace to access the WebXR Device API
      const xrSession = new webxr.Session({optionalFeatures: ['dom-overlay'], requiredFeatures: ['hit-test']});
      const scene = new THREE.Scene();

      // Set up a WebGLRenderer to render the scene
      const renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Set up a perspective camera with a default field of view
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 0);
      scene.add(camera);

      // Add a directional light to the scene
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1).normalize();
      scene.add(light);

      // Load a 3D model to display in the scene
      const loader = new THREE.GLTFLoader();
      loader.load('https://raw.githubusercontent.com/quirinbatsch/testingAR/main/pinkbear.gltf', function (gltf) {
        scene.add(gltf.scene);
      });

      // Set up the AR capabilities
      let arToolkitSource = new THREEx.ArToolkitSource({
        sourceType: 'webcam',
      });
      arToolkitSource.init(function onReady() {
        onResize();
      });
      window.addEventListener('resize', function () {
        onResize();
      });

      let arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'https://raw.githubusercontent.com/nicolocarpignoli/nicolocarpignoli.github.io/master/assets/data/camera_para.dat',
        detectionMode: 'mono',
      });
      arToolkitContext.init(function onCompleted() {
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      });

      let arToolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, camera, {
        type: 'pattern',
        patternUrl: 'https://raw.githubusercontent.com/jeromeetienne/AR.js/master/three.js/examples/marker-training/examples/pattern-files/pattern-hiro.patt',
        changeMatrixMode: 'cameraTransformMatrix',
      });

      // Add a mesh to represent the detected surface
      const surfaceMesh = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(1, 1, 1, 1),
        new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide}),
      );
      surfaceMesh.rotation.x = -Math.PI / 2;
      surfaceMesh.visible = false;
      scene.add(surfaceMesh);

      // Set up the hit test source and hit test renderer
      let hitTestSource = null;
      xrSession.addEventListener('end', onEnd);
      xrSession.addEventListener('select', onSelect);
      xrSession.requestReferenceSpace('viewer').then((referenceSpace) => {
        hit
